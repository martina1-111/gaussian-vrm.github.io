<!DOCTYPE html>
<head>
  <title>Simple GVRM Viewer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Courier New', monospace;
      background: #fff;
    }
    .container {
      display: flex;
      height: 100vh;
      width: 100%;
      padding: 20px 40px;
      box-sizing: border-box;
      align-items: center;
    }
    .canvas-container {
      flex: 0 0 40%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 40px;
      position: relative;
      background: #000;
      border-radius: 10px;
    }

    @media (max-width: 608px) {
      .container {
        flex-direction: column;
        padding: 20px;
      }
      .canvas-container {
        flex: none;
        width: 100%;
        margin-right: 0;
        margin-bottom: 20px;
      }
      .code-container {
        flex: none;
        width: 100%;
        max-height: 50vh;
      }
    }
    .canvas-container canvas {
      width: 480px;
      height: 480px;
      border-radius: 10px;
      display: block;
    }
    .code-container {
      flex: 1;
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 20px;
      overflow-y: auto;
      font-size: 14px;
      line-height: 1.6;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    .enable-button {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 10px 20px;
      background: #ffcc99;
      color: #000;
      border: none;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .enable-button:hover {
      background: #ffd9b3;
    }
    .loading-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Courier New', monospace;
      font-size: 16px;
      color: #fff;
      display: none;
    }
    .code-container pre {
      margin: 0;
      white-space: pre;
    }
    .code-title {
      color: #4ec9b0;
      font-weight: bold;
      margin-bottom: 15px;
      font-size: 16px;
    }
    .keyword { color: #c586c0; }
    .string { color: #ce9178; }
    .function { color: #dcdcaa; }
    .comment { color: #6a9955; }
    .number { color: #b5cea8; }
    .drag-hint {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #fff;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
      pointer-events: none;
      display: none;
      animation: dragHintSlide 2s ease-in-out infinite;
      opacity: 0.8;
    }
    @keyframes dragHintSlide {
      0%, 100% {
        transform: translate(-90%, -50%);
      }
      50% {
        transform: translate(-10%, -50%);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="canvas-container">
      <canvas id="canvas"></canvas>
      <button id="enableButton" class="enable-button" style="display: none;">Enable Simple Viewer</button>
      <div id="loadingText" class="loading-text">loading<span id="loadingDots">.</span></div>
      <div id="dragHint" class="drag-hint">ðŸ‘†</div>
    </div>
    <div class="code-container">
      <div class="code-title">// JavaScript Code</div>
      <pre><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">'three'</span>;
<span class="keyword">import</span> { GVRM } <span class="keyword">from</span> <span class="string">'gvrm'</span>;

<span class="keyword">const</span> canvas = document.<span class="function">getElementById</span>(<span class="string">'canvas'</span>);
<span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.<span class="function">WebGLRenderer</span>({ canvas });
renderer.<span class="function">setSize</span>(<span class="number">480</span>, <span class="number">480</span>);

<span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.<span class="function">Scene</span>();

<span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.<span class="function">PerspectiveCamera</span>(<span class="number">65</span>, <span class="number">1</span>, <span class="number">0.01</span>, <span class="number">100</span>);
camera.position.<span class="function">set</span>(<span class="number">0</span>, <span class="number">0.6</span>, <span class="number">1.6</span>);
camera.<span class="function">lookAt</span>(<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0</span>);

<span class="comment">// GVRM</span>
<span class="keyword">const</span> targetPath = <span class="string">'./target.gvrm'</span>;
<span class="keyword">const</span> idlePath = <span class="string">'./Idle.fbx'</span>;
<span class="keyword">const</span> avatarCount = <span class="number">10</span>;
<span class="keyword">const</span> spawnRadius = <span class="number">1.2</span>;
<span class="keyword">const</span> gvrms = [];

<span class="keyword">const</span> randomSpawn = () => {
  <span class="keyword">const</span> angle = Math.<span class="function">random</span>() * Math.<span class="function">PI</span> * <span class="number">2</span>;
  <span class="keyword">const</span> radius = Math.<span class="function">sqrt</span>(Math.<span class="function">random</span>()) * spawnRadius;
  <span class="keyword">return</span> { x: Math.<span class="function">cos</span>(angle) * radius, z: Math.<span class="function">sin</span>(angle) * radius };
};

<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; avatarCount; i++) {
  <span class="keyword">const</span> container = <span class="keyword">new</span> THREE.<span class="function">Group</span>();
  scene.<span class="function">add</span>(container);

  <span class="keyword">const</span> gvrm = <span class="keyword">await</span> GVRM.<span class="function">load</span>(targetPath, container, camera, renderer);  <span class="comment">// 1/3</span>
  <span class="keyword">await</span> gvrm.<span class="function">changeFBX</span>(idlePath);  <span class="comment">// 2/3</span>

  <span class="keyword">const</span> spawn = <span class="function">randomSpawn</span>();
  container.position.<span class="function">set</span>(spawn.x, <span class="number">0</span>, spawn.z);
  container.rotation.y = Math.<span class="function">random</span>() * Math.<span class="function">PI</span> * <span class="number">2</span>;

  gvrms.<span class="function">push</span>(gvrm);
}

renderer.<span class="function">setAnimationLoop</span>(() => {
  gvrms.<span class="function">forEach</span>((gvrm) => gvrm.<span class="function">update</span>());  <span class="comment">// 3/3</span>
  renderer.<span class="function">render</span>(scene, camera);
});</pre>
    </div>
  </div>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.min.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
        "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@2.1.0/lib/three-vrm.module.js",
        "gaussian-splats-3d": "https://naruya.github.io/gs-edit/lib/gaussian-splats-3d.module.js",
        "jszip": "https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm",
        "gvrm": "https://naruya.github.io/gs-edit/lib/gaussian-vrm.min.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GVRM } from 'gvrm';

    const enableButton = document.getElementById('enableButton');
    const loadingText = document.getElementById('loadingText');
    const loadingDots = document.getElementById('loadingDots');
    let viewerEnabled = false;
    let dotsInterval = null;

    async function initViewer() {
      if (viewerEnabled) return;
      viewerEnabled = true;

      if (enableButton) {
        enableButton.style.display = 'none';
      }

      // Show loading
      loadingText.style.display = 'block';

      // Animate dots
      let dotCount = 1;
      dotsInterval = setInterval(() => {
        dotCount = (dotCount % 3) + 1;
        loadingDots.textContent = '.'.repeat(dotCount);
      }, 500);

      const canvas = document.getElementById('canvas');
      const renderer = new THREE.WebGLRenderer({ canvas });
      renderer.setSize(480, 480);

      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(65, 1, 0.01, 100);
      camera.position.set(0, 0.6, 1.6);
      camera.lookAt(0, 0.2, 0);

      // OrbitControls for drag interaction
      const controls = new OrbitControls(camera, canvas);
      controls.target.set(0, 0.2, 0);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.update();

      // GVRM
      const targetPath = './target.gvrm';
      const idlePath = './Idle.fbx';
      const avatarCount = 10;
      const spawnRadius = 1.2;
      const gvrms = [];

      const randomSpawn = () => {
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.sqrt(Math.random()) * spawnRadius;
        return { x: Math.cos(angle) * radius, z: Math.sin(angle) * radius };
      };

      for (let i = 0; i < avatarCount; i++) {
        const container = new THREE.Group();
        scene.add(container);

        const gvrm = await GVRM.load(targetPath, container, camera, renderer);  // 1/3
        await gvrm.changeFBX(idlePath);  // 2/3

        const spawn = randomSpawn();
        container.position.set(spawn.x, 0, spawn.z);
        container.rotation.y = Math.random() * Math.PI * 2;

        gvrms.push(gvrm);
      }

      // Hide loading
      if (dotsInterval) {
        clearInterval(dotsInterval);
      }
      loadingText.style.display = 'none';

      // Show drag hint after a short delay
      const dragHint = document.getElementById('dragHint');
      setTimeout(() => {
        dragHint.style.display = 'block';
      }, 500);

      // Hide drag hint on first interaction
      let hasInteracted = false;
      const hideDragHint = () => {
        if (!hasInteracted) {
          hasInteracted = true;
          dragHint.style.display = 'none';
        }
      };
      canvas.addEventListener('mousedown', hideDragHint);
      canvas.addEventListener('touchstart', hideDragHint);

      // Fixed FPS (30 FPS)
      const targetFPS = 30;
      const frameInterval = 1000 / targetFPS;
      let lastFrameTime = 0;

      renderer.setAnimationLoop((currentTime) => {
        const deltaTime = currentTime - lastFrameTime;

        if (deltaTime >= frameInterval) {
          lastFrameTime = currentTime - (deltaTime % frameInterval);

          controls.update();  // Update controls
          gvrms.forEach((gvrm) => gvrm.update());  // 3/3
          renderer.render(scene, camera);
        }
      });
    }

    // Check screen size and decide whether to auto-load or show button
    let screenWidth;
    try {
      screenWidth = window.top.innerWidth;
    } catch (e) {
      screenWidth = window.innerWidth;
    }

    if (screenWidth < 1024) {
      // Show button for smaller screens
      enableButton.style.display = 'block';
      enableButton.addEventListener('click', initViewer);
    } else {
      // Auto-load for larger screens
      initViewer();
    }
  </script>
</body>
</html>
